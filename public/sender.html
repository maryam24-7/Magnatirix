<script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.min.js"></script>
<script>
    async function sendMessage() {
        const submitBtn = document.querySelector('#messageForm [type="submit"]');
        const originalText = submitBtn.innerHTML;
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> جاري الإرسال...';
        submitBtn.disabled = true;

        try {
            // 1. جمع البيانات
            const recipients = Array.from(document.querySelectorAll('input[name="recipients[]"]')).map(i => i.value);
            const subject = document.getElementById('subject').value;
            const message = document.getElementById('message').value;

            // 2. توليد مفتاح AES عشوائي
            const aesKey = CryptoJS.lib.WordArray.random(32); // 256-bit

            // 3. تشفير الرسالة باستخدام AES
            const encryptedMessage = CryptoJS.AES.encrypt(message, aesKey).toString();

            // 4. توليد HMAC للتحقق من سلامة البيانات
            const hmac = CryptoJS.HmacSHA256(encryptedMessage, aesKey).toString();

            // 5. تحميل مفتاح RSA العمومي للمستلم من API (أو توليده وهميًا هنا لأغراض العرض)
            // مثال: مفتاح عمومي ثابت بصيغة PEM أو JWK (يفترض أن يكون حقيقيًا من جهة السيرفر)
            const publicKeyPem = `-----BEGIN PUBLIC KEY-----
... RSA PUBLIC KEY هنا ...
-----END PUBLIC KEY-----`;

            const publicKey = await importRSAPublicKey(publicKeyPem, 'RSA-OAEP');

            // 6. تشفير مفتاح AES باستخدام RSA
            const encryptedAesKey = await window.crypto.subtle.encrypt(
                { name: "RSA-OAEP" },
                publicKey,
                aesKey.words.reduce((arr, word) => arr.concat([
                    (word >> 24) & 0xff,
                    (word >> 16) & 0xff,
                    (word >> 8) & 0xff,
                    word & 0xff
                ]), [])
            );

            // 7. تجهيز البيانات للإرسال
            const payload = {
                to: recipients,
                subject,
                encryptedMessage,
                hmac,
                encryptedAesKey: btoa(String.fromCharCode(...new Uint8Array(encryptedAesKey)))
            };

            // 8. إرسال البيانات للسيرفر (مثال: console.log فقط حالياً)
            console.log("بيانات مشفرة:", payload);

            alert("تم إرسال الرسالة المشفرة بنجاح");
        } catch (err) {
            console.error("خطأ أثناء التشفير أو الإرسال:", err);
            alert("حدث خطأ أثناء التشفير");
        } finally {
            submitBtn.innerHTML = originalText;
            submitBtn.disabled = false;
        }
    }

    // مساعد لتحويل PEM إلى مفتاح RSA
    async function importRSAPublicKey(pem, algorithm) {
        // إزالة رأس وذيل الشهادة وتحويلها إلى binary
        const b64 = pem.replace(/-----.*?-----/g, '').replace(/\s/g, '');
        const binaryDer = Uint8Array.from(atob(b64), c => c.charCodeAt(0));

        return window.crypto.subtle.importKey(
            'spki',
            binaryDer,
            {
                name: algorithm,
                hash: 'SHA-256',
            },
            true,
            ['encrypt']
        );
    }
</script>
