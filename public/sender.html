<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>مرسل الرسالة | Message Sender</title>
  <link rel="stylesheet" href="css/style.css">
</head>
<body>
  <div class="header">
    <button id="languageToggle" class="btn language-toggle">English</button>
    <h1 id="main-title">مرسل الرسالة</h1>
  </div>

  <div class="container">
    <div class="card">
      <h2 id="form-title">إرسال رسالة مشفرة</h2>
      
      <form id="senderForm">
        <div class="form-group">
          <label for="username" id="username-label">اسمك:</label>
          <input type="text" id="username" class="form-control" required>
        </div>
        
        <div class="form-group">
          <label for="receiver" id="receiver-label">اسم المستقبل:</label>
          <input type="text" id="receiver" class="form-control" required list="userList">
          <datalist id="userList"></datalist>
        </div>
        
        <div class="form-group">
          <label for="message" id="message-label">الرسالة:</label>
          <textarea id="message" class="form-control" rows="4" required></textarea>
        </div>
        
        <button type="submit" class="btn btn-accent" id="submit-btn">إرسال</button>
      </form>
      
      <div id="result" class="result info" style="display: none;"></div>
    </div>
    
    <a href="index.html" class="btn btn-secondary" id="back-link">العودة إلى الصفحة الرئيسية</a>
  </div>

  <script>
    const translations = {
      ar: {
        mainTitle: "مرسل الرسالة",
        formTitle: "إرسال رسالة مشفرة",
        usernameLabel: "اسمك:",
        receiverLabel: "اسم المستقبل:",
        messageLabel: "الرسالة:",
        submitBtn: "إرسال",
        backLink: "العودة إلى الصفحة الرئيسية",
        languageToggle: "English",
        successMessage: "تم إرسال الرسالة بنجاح.",
        errorMessage: "حدث خطأ أثناء إرسال الرسالة.",
        loadingUsers: "جاري تحميل قائمة المستخدمين..."
      },
      en: {
        mainTitle: "Message Sender",
        formTitle: "Send Encrypted Message",
        usernameLabel: "Your Name:",
        receiverLabel: "Recipient Name:",
        messageLabel: "Message:",
        submitBtn: "Send",
        backLink: "Back to Home",
        languageToggle: "العربية",
        successMessage: "Message sent successfully.",
        errorMessage: "Error sending message.",
        loadingUsers: "Loading users list..."
      }
    };

    // Load active users for autocomplete
    async function loadActiveUsers() {
      try {
        const response = await fetch('/users');
        const users = await response.json();
        const userList = document.getElementById('userList');
        
        userList.innerHTML = users.map(user => 
          `<option value="${user}">${user}</option>`
        ).join('');
      } catch (error) {
        console.error('Error loading users:', error);
      }
    }

    document.getElementById('languageToggle').addEventListener('click', function() {
      const html = document.documentElement;
      const currentLang = html.lang;
      const newLang = currentLang === 'ar' ? 'en' : 'ar';
      
      // Update HTML attributes
      html.lang = newLang;
      html.dir = newLang === 'ar' ? 'rtl' : 'ltr';
      
      // Update all translatable elements
      document.getElementById('main-title').textContent = translations[newLang].mainTitle;
      document.getElementById('form-title').textContent = translations[newLang].formTitle;
      document.getElementById('username-label').textContent = translations[newLang].usernameLabel;
      document.getElementById('receiver-label').textContent = translations[newLang].receiverLabel;
      document.getElementById('message-label').textContent = translations[newLang].messageLabel;
      document.getElementById('submit-btn').textContent = translations[newLang].submitBtn;
      document.getElementById('back-link').textContent = translations[newLang].backLink;
      document.getElementById('languageToggle').textContent = translations[newLang].languageToggle;
      
      // Save preference to localStorage
      localStorage.setItem('preferredLang', newLang);
    });

    // Check for saved language preference
    const savedLang = localStorage.getItem('preferredLang');
    if (savedLang && savedLang !== document.documentElement.lang) {
      document.getElementById('languageToggle').click();
    }

    const socket = new WebSocket('wss://' + window.location.host);
    let myUsername = "";

    document.getElementById('senderForm').addEventListener('submit', async function (e) {
      e.preventDefault();

      const username = document.getElementById('username').value;
      const receiver = document.getElementById('receiver').value;
      const message = document.getElementById('message').value;

      const resultElement = document.getElementById('result');
      resultElement.style.display = 'none';

      try {
        if (!myUsername) {
          myUsername = username;
          const keyPair = await window.crypto.subtle.generateKey(
            { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" },
            true, ["encrypt", "decrypt"]
          );
          window.myPrivateKey = keyPair.privateKey;
          const publicKeyPem = await exportPublicKeyToPEM(keyPair.publicKey);
          socket.send(JSON.stringify({ type: "register", username, publicKey: publicKeyPem }));
        }

        const receiverKey = await fetch(`/public-key/${receiver}`).then(res => {
          if (!res.ok) throw new Error(translations[document.documentElement.lang].errorMessage);
          return res.text();
        });

        const aesKey = window.crypto.getRandomValues(new Uint8Array(32));
        const iv = window.crypto.getRandomValues(new Uint8Array(16));
        const encodedMessage = new TextEncoder().encode(message);

        const cryptoKey = await window.crypto.subtle.importKey('raw', aesKey, 'AES-CBC', false, ['encrypt']);
        const encrypted = await window.crypto.subtle.encrypt({ name: 'AES-CBC', iv }, cryptoKey, encodedMessage);

        const hmacKey = await window.crypto.subtle.importKey('raw', aesKey, { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);
        const hmac = await window.crypto.subtle.sign('HMAC', hmacKey, new TextEncoder().encode(arrayBufferToBase64(encrypted)));

        const receiverCryptoKey = await importRSAPublicKey(receiverKey);
        const encryptedKey = await window.crypto.subtle.encrypt({ name: 'RSA-OAEP' }, receiverCryptoKey, aesKey);

        socket.send(JSON.stringify({
          sender: username,
          receiver,
          encryptedMessage: arrayBufferToBase64(encrypted),
          iv: arrayBufferToBase64(iv),
          encryptedKey: arrayBufferToBase64(encryptedKey),
          hmac: arrayBufferToBase64(hmac)
        }));

        resultElement.textContent = translations[document.documentElement.lang].successMessage;
        resultElement.className = 'result success';
        resultElement.style.display = 'block';
        
        // Clear message field after successful send
        document.getElementById('message').value = '';
      } catch (error) {
        console.error('Error:', error);
        resultElement.textContent = `${translations[document.documentElement.lang].errorMessage} ${error.message}`;
        resultElement.className = 'result error';
        resultElement.style.display = 'block';
      }
    });

    async function exportPublicKeyToPEM(key) {
      const exported = await window.crypto.subtle.exportKey('spki', key);
      const exportedAsString = btoa(String.fromCharCode(...new Uint8Array(exported)));
      return `-----BEGIN PUBLIC KEY-----\n${exportedAsString.match(/.{1,64}/g).join('\n')}\n-----END PUBLIC KEY-----`;
    }

    function arrayBufferToBase64(buffer) {
      return btoa(String.fromCharCode(...new Uint8Array(buffer)));
    }

    function base64ToArrayBuffer(base64) {
      const binaryString = atob(base64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    async function importRSAPublicKey(pem) {
      const b64 = pem.replace(/-----.*?-----/g, '').replace(/\s/g, '');
      const binary = atob(b64);
      const array = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) array[i] = binary.charCodeAt(i);
      return window.crypto.subtle.importKey('spki', array.buffer, { name: 'RSA-OAEP', hash: 'SHA-256' }, false, ['encrypt']);
    }

    // Load active users on page load
    loadActiveUsers();
    
    // Refresh users list every 10 seconds
    setInterval(loadActiveUsers, 10000);
  </script>
</body>
</html>
